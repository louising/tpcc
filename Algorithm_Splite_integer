## Alogrithm: Splite integer

 1: 4
 2: 3 + 1
 3: 2 + 2
 4: 2 + 1 + 1
 5: 1 + 1 + 1 + 1
 
 1: 5
 2: 4 + 1
 3: 3 + 2
 4: 3 + 1 + 1
 5: 2 + 2 + 1
 6: 2 + 1 + 1 + 1
 7: 1 + 1 + 1 + 1 + 1
 
 1: 6
 2: 5 + 1
 3: 4 + 2
 4: 4 + 1 + 1
 5: 3 + 3
 6: 3 + 2 + 1
 7: 3 + 1 + 1 + 1
 8: 2 + 2 + 2
 9: 2 + 2 + 1 + 1
10: 2 + 1 + 1 + 1 + 1
11: 1 + 1 + 1 + 1 + 1 + 1

public static void main(String[] args) {
    //System.out.println(getCount(7,7)); // 4-5; 5-7; 6-11 7-15
    
    List<List<Integer>> result = partition(5);
    for (List<Integer> combination : result) {
        System.out.printf("%2d: %s\n", num++, combination.stream().map(String::valueOf).reduce((a, b) -> a + " + " + b).orElse(""));
    }
}      

public static List<List<Integer>> partition(int n) {
    List<List<Integer>> result = new ArrayList<>();
    partitionHelper(n, n, new ArrayList<>(), result);
    return result;
}
private static void partitionHelper(int n, int max, List<Integer> current, List<List<Integer>> result) {
    if (n == 0) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = Math.min(max, n); i >= 1; i--) {
        current.add(i);
        partitionHelper(n - i, i, current, result);
        current.remove(current.size() - 1);
    }
}

static int getCount(int n, int max) {
    if (n == 1 || max == 1) {
        return 1;
    }
    if (n < max) {
        return getCount(n, n);
    }
    if (n == max) {
        return 1 + getCount(n, n-1);
    } else {
        return getCount(n-max, max) + getCount(n, max - 1);
    }
}        
